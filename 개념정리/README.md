# 빅오 표기법  (Git O notation)  

알고리즘이 얼마나 빠른지 표시하는 방법  

**실행시간이 얼마나 걸리는 지만 고려할 것이 아니라, 리스트가 증가할 때 어떻게 증가하는 지를 파악하기 위해 사용한다.**  

* 알고리즘이 동작하기 위해 필요한 연산 횟수를 비교하기 위한 표기법  
* 입력 데이터의 크기가 늘어날 때 알고리즘의 실행 속도가 얼마나 증가하는 지 알 수 있다.  
* O(log n)는 O(n)보다 빠르고, 찾으려는 원소의 개수가 증가하면 상대적으로 더 빨라진다.  
* 최악(worst case)의 경우에 대한 값이다.  
    - 단순 탐색은 O(n)인데, 1번만에 찾았다고 해서 O(1)이 아니라는 것  


**대표적인 5개의 빅오 실행 시간**  
* O(log n), 로그시간 : 예) 이진탐색  
* O(n), 선형시간 : 예) 단순탐색
* O(n * log n) : 예) 선택 정렬과 같이 느린 정렬 알고리즘  
* O(n!) : 예) 많이 느린 알고리즘  

# 해시 알고리즘  

## 해시 함수

문자열을 받아서 숫자를 반환한다.  
O(1)  
필요한 값이 있을 시 탐색할 필요 없이, 해당 Key 값을 통해 바로 찾을 수 있도록  

### 특징 

* 같은 이름에 대해서는 항상 같은 인덱스를 할당한다.  
* 다른 문자열에 대해서는 다른 인덱스를 할당한다.  
* 배열이 얼마나 큰 지 알고 있어야 하며, 유효한 인덱스만 반환해야 한다.  

## 해시 테이블

* 해시함수와 배열을 합치면 **해시 테이블**이라고 하는 자료구조를 얻을 수 있다.  
* 해시 테이블은 해시 함수를 사용해서 더 총명하게 어디에 원소를 저장할 지 결정한다.  
* 빠른 속도 (배열을 사용하기 때문에)  
* Key-Value를 가진다.  

### 예시 
* 해시테이블로 조회하기 (전화번호부)  
* 중복된 항목을 방지하기  
    * Key-Value가 들어오면 해당 Key를 통해 해당 Value가 이미 있는지 검사
* 해시테이블을 캐시로 사용하기  
    * 브라우저를 통해 페이지에 방문할 때마다 서버는 먼저 해시테이블에 저장된 페이지가 있는지 확인한다.  

### 충돌  

* 서로 다른 키를 배열의 서로 다른 위치에 저장하기란 쉽지 않다.  
* 이미 공간을 차지하고 있는데, 값을 넣는 것을 **충돌**이라고 한다.  

**해결 방법**  

* 같은 공간에 여러 개의 키를 연결 리스트로 만들어 넣기  
    * 연결리스트를 뒤져야 하므로 찾는데 시간이 더 걸린다.  
    * 다른 공간은 낭비된다. 결국 연결리스트를 이용하는 꼴  

**해시의 조건**  
* 해시 함수는 키를 해시테이블 전체에 고르게 할당해야 한다.  
* 연결 리스트가 길어지면 해시 테이블의 속도도 느려진다. 하지만 좋은 해시 함수가 있다면 그런 일은 발생하지 않는다.  

**충돌을 피하기 위해 필요한 것**   
* 낮은 사용률 / 좋은 해시함수  

**좋은 해시함수란?**  
* 배열에 값을 고루 분포시키는 함수